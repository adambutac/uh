<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"> <html> <head> <title>ICS 311 #24: NP-Completeness
</title> </head>

<body>
<hr><h1><a href="../index.html">ICS 311</a> #24: NP-Completeness </h1><hr> 

<!-- ------------------------------------------------------------ -->
<h2>Outline</h2> 
<ol>
  <li> Don't Let This Happen to You</li>
  <li> Problem Classes</li>
  <li> P and NP Classes</li>
  <li> Encoding Problems and Polynomial Time Verification </li>
  <li> NP Completeness </li>
  <li> Constructing NPC </li>
  <li> NP Complete Problems</li>
</ol>

    
<h2>Readings and Screencasts</h2>
<ul>
  <li>CLRS 3rd Ed. Chapter 34 (read for the main concepts).</li>
  <li>Screencasts <a href="http://youtu.be/Cm_c_y2z0HY">24 A</a> Introduction to Concepts,
                  <a href="http://youtu.be/H4OYXaVkLA4">24 B</a> An Initial NPC Problem,
                  <a href="http://youtu.be/J5l-crl0LgA">24 C</a> More NPC Problems. 
  </li>
</ul> 

<!-- ------------------------------------------------------------ -->
<hr><h2> Don't Let This Happen to You </h2>

<p>Suppose you worked in industry, and your boss calls you to his office and says they want to
enter the emerging "iThingy" market. He wants to offer customized iThingies, and it's important to
have an algorithm that, given a specification, can efficiently construct a design that meets the
maximum number of requirements in the lowest cost way.</p>

<img src="Topic-24/garey-johnson-cartoon-1.jpg" align="right" hspace="5">
<p>You try for weeks but just can't seem to find an efficient solution. Every solution that you come
up with amounts to trying all combinations of components, in exponential time. More efficient
algorithms fail to find optimal solutions.</p>

<p>You don't want to have to go your boss and say "I'm sorry I can't find an efficient solution. I
guess I'm just too dumb." </p>

<img src="Topic-24/garey-johnson-cartoon-2-you.jpg" align="left" hspace="5">
<p>You would like to be able to confidently stride into his office and say "I can't find an
efficient solution because no such solution exists!" Unfortunately, proving that the problem is
inherently intractable is also very hard: in fact, no one has succeeded in doing so.</p>


<img src="Topic-24/garey-johnson-cartoon-3.jpg" align="right" hspace="5">

<p>Today we introduce a class of problems that no one has been able to prove is intractable, but nor
has anyone been able to find an efficient solution to any of them.</p>

<p>If you can show that the iThingy configuration problem is one of these problems, you can go to
your boss and say, "I can't find an efficient solution, but neither can all these smart and famous
computer scientists!"</p>

<p>(In <a href="Topic-25.html">Topic 25</a> we'll cover what you would say next. Thanks to Garey
&amp; Johnson (1979) for the story and images.)</p>

<!-- ------------------------------------------------------------ -->
<hr><h2> Problem Classes </h2>

<p>For most of this semester, we abstracted away from the study of particular
<b><em>implementations</em></b> to study the computational complexity of <b><em>algorithms</em></b>
independently of their implementation. More precisely, we made universally quantified statements to
the effect that all possible implementations of an algorithm would exhibit certain asymptotic growth
within constant factors of each other. </p>

<p>Now we abstract further, to study the computational complexity of <b><em>problems</em></b>,
independently of the algorithms used to solve them. We will be trying to make universally quantified
statements about the computational complexity of all possible algorithms for a problem. (We won't
always succeed in doing this.) </p>

<p>For example, when we showed that any comparison-based sorting algorithm is O(<i>n</i> lg
 <i>n</i>) in <a href="Topic-10.html">Topic 10</a>, we were making a claim about a class of
 algorithms for a problem.</p>

<!-- ---------------------------- -->
<h3>Tractability and Decidability</h3>

<p>Broadly, we are concerned with three classes of problems:</p>
<ul>

  <li><b>Tractable problems</b>, generally considered to be those solvable in polynomial time (most
      of the problems considered so far in this course).
    <ul>
      <li><em>Examples:</em> Any problem studied this semester for which we have solutions bounded by
          <i>n<sup>k</sup></i> for a fixed constant <i>k</i>.
      </li>
      <li>Some solutions are not strictly polynomial but are bounded above by a polynomial (e.g.,
          <i>n</i> lg <i>n</i> for sorting is bounded by <i>n<sup>2</sup></i>), so sorting is
          considered polynomial.</li>
    </ul>
  </li><br>
  
  <li><b>Intractable problems</b> are those solvable in super-polynomial but not polynomial
      time. Today we will be concerned with the question of which problems are in this
      class.
    <ul>
      <li><em>Examples:</em> Enumerate all binary strings of length <i>n</i>; Compute the power set (set of
          all sets) of <i>n</i> items. The solutions consist of 2<sup><i>n</i></sup> binary strings,
          or 2<sup><i>n</i></sup> sets, respectively, so even if the solution were available
          instantly, exponential time would be required just to output the result!</li>
      <li><em>Unknown:</em> Integer linear programming, finding longest simple paths in a graph, finding the
      optimal way to schedule tasks on factory machines under scheduling and deadline constraints,
      determining whether certain boolean formulas can be simultaneously satisfied, optimizing
      circuit layouts under certain constraints, finding the cheapest way to visit all of a set of
      cities without repeating any and returning to your starting city, finding the optimal
      partition of graphs under a modularity metric, and many many more ...</li>
    </ul>
  </li><br> 
    
  <li><b>Unsolvable problems</b> for which no algorithm can be given guaranteed to solve all
       instances of the problem. These problems are also known as <i><b>Undecidable</b></i>. 
    <ul>
      <li>Example: the <i><b>halting problem</b></i> (given a description of
       a program and arbitrary input, decide whether the program will halt on that input),
       demonstrated by Alan Turing.</li>
    </ul>
  </li> 

</ul>

<h3>Hierarchy of Problem Classes</h3>

<p>The hierarchy of problem classes was illustrated at the beginning of the semester with
this diagram:</p>

<img src="Topic-24/Complexity-Hierarchy.jpg">

<p>We have spent most of our time on problems in the lower half of this diagram. Now we consider
whether there are problems that are <em>intrisically</em> in the upper half.</p>

<!-- ------------------------------------------------------------ -->
<hr><h2> P and NP Classes </h2>

<p><b>P</b> denotes the class of problems solvable in polynomial time, such as most of the problems
we have considered this semester.</p>

<!-- ---------------------------- -->
<h3> Nondeterministic Polynomial </h3>

<p><b>NP</b> denotes the class of problems for which solutions are <em><b>verifiable</b></em> in
polynomial time: given a description of the problem <i>x</i> and a "certificate" <i>y</i> describing
a solution (or providing enough information to show that a solution exists) that is polynomial in
the size of <i>x</i>, we can check the solution (or verify that a solution exists) in polynomial
time as a function of <i>x</i> and <i>y</i>.</p>

<p>Problems in NP are <b>decision problems</b>: we answer "yes" or "no" to whether the certificate
is a solution. The polynomial size requirement on <i>y</i> rules out problems that take exponential
time just to output their results, such as the enumeration of all binary strings of length
<i>n</i>. (One could check the solution in time polynomial in <i>y</i>, but <i>y</i> would be
exponential in <i>x</i>, so overall the problem is not tractable.)</p>

<p>These problems are called "nondeterministic polynomial" because one way of defining them is to
suppose we have a <b>nondeterministic machine</b> that, whenever faced with a choice, can guess the
correct alternative, producing a solution in polynomial time based on this guess. (Amazingly, no
one has been able to prove that such a fanciful machine would help!)</p>

<p>Another way to think of this is that the machine can copy itself at each choice point,
essentially being multithreaded on an infinite number of processors and returning the solution as
soon as the solution is found down a span of polynomial depth (see <a href="Topic-22.html">Topic on
Multithreading</a>).</p>

<p>(Your text does not take either of these approaches, preferring the "certificate"
definition. We elaborate on this later, but not in depth.)</p> 

<img src="Topic-24/money.jpg" align="right" hspace="5">

<!-- ---------------------------- -->
<h3>Relationship of P to NP</h3>

<p>Clearly, P is a subset of NP.</p>

<p>The million dollar question (literally, see the <a
 href="http://www.claymath.org/millennium-problems/rules-millennium-prizes"> Clay Mathematics
Institute Millenium Prize</a> for the <a
 href="http://www.claymath.org/millenium-problems/p-vs-np-problem"> P vs NP Problem </a>), is
whether P is a strict subset of NP (i.e., whether there are problems in NP that are not in P, so are
inherently exponential).</p>

<img src="Topic-24/P-NP-NPC-NPH.jpg" align="right" hspace="5">

<!-- ---------------------------- -->
<h3>NP Completeness</h3>

<p>Theorists <em>have</em> been able to show that there are problems that are just as hard as
any problem in NP, in that if any of these <b>NP-Hard</b> problems are solved then any 
problem in NP can be solved by reduction to (translating them into instances of) the NP-Hard
problem.</p>

<p>Those NP-Hard problems that are also in NP are said to be <b> NP Complete</b>, denoted
<b>NPC</b>, in that if <em>any</em> NPC problem can be solved in polynomial time then <em>all</em>
problems in NP can also be solved in polynomial time.</p> 

<p>The study of NP Completeness is important: the <i>most cited reference in all of Computer
Science</i> is Garey &amp; Johnson's (1979) book Computers and Intractability: A Guide to the Theory of
NP-Completeness. (Your textbook is the second most cited reference in Computer Science!) </p>

<p>In 1979 Garey &amp; Johnson wrote, "The question of whether or not the NP-complete problems are
intractable is now considered to be one of the foremost open questions of contemporary mathematics
and computer science."</p>

<img src="Topic-24/shrug.jpg" align="right" hspace="5">

<p>Over 30 years later, in spite of a million dollar prize offer and intensive
study by many of the best minds in computer science, this is still true: No one has been able to either
<ul>
  <li>Prove that there are problems in NP that cannot be solved in polynomial time (which would mean
  P &ne; NP), or </li>
  <li>Find a polynomial time solution for a single NP Complete Problem (which would mean P=NP).</li>
</ul>

<p>Although either alternative is possible, most computer scientists believe that P &ne;
NP.</p>

<!-- ---------------------------- -->
<h3>Discriminating P and NP problems</h3>

<p>Problems that look very similar to each other may belong to different complexity classes (if P
&ne; NP), for example:</p>

<ul>
  <li><b>Linear programming</b> can be solved in polynomial time (the <a
    href="Topic-21.html">simplex algorithm</a>), but if we require that the assigned values be
    integers we have the <b>integer linear programming problem</b>, which is NP-Hard. </li><br>
  <li><b>Shortest paths</b> in a graph <a href="Topic-18.html">can be found in O(<i>VE</i>) or
    better</a>, but the problem of finding <b>longest simple paths</b> is NP-Hard (deciding whether
    there is a path longer than length <i>k</i> is NP-Complete).</li><br>
  <li>An <b>Euler tour</b> that traverses each edge of a graph once can be found in O(<i>E</i>)
    time, but finding a <b>Hamiltonian cycle</b> that traverses each vertex exactly once via a
    simple cycle is NP-Hard.</li><br>
  <li>We can determine whether a boolean formula in <b>2-Conjunctive Normal Form</b> is satisfiable
    in polynomial time, but doing the same for a formula in <b>3-Conjunctive Normal Form</b> is
    NP-Complete.</li> 
</ul> 

<p>Clearly, it is important that we be able to recognize such problems when we encounter them and
not share the fate of the iThingy algorithm designer. (In <a href="Topic-25.html">the next topic</a>
we'll discuss approximation algorithms for dealing with them in a practical way.)</p>

<!-- ------------------------------------------------------------ -->
<hr><h2>Encoding Problems and Polynomial Time Verification </h2>

<!-- ***** CONSIDER REMOVING THE FORMAL LANGUAGE ANGLE ***** -->

<p><i>This section discusses some concepts used in the study of complexity classes. We are not
delving into formal proofs such as those provided in the text. The main purpose of this section is
to give you familiarity with the terminology and to show why the remaining notes talk about
"languages".</i></p>

<!-- ---------------------------- -->
<h3>Abstract Problems</h3>

<p>An <b>abstract problem</b> <i>Q</i> is a binary relation mapping problem <b>instances</b> <i>I</i> to
problem <b>solutions</b> <i>S</i>.</p> 

<p>NP Completeness is concerned with <b>decision problems</b>: those having a yes/no answer, or in
which <i>Q</i> maps <i>I</i> to {0, 1}. </p>

<p>Many problems are <b>optimization problems</b>, which require that some value be minimized (e.g.,
finding shortest paths) or maximized (e.g., finding longest paths).</p>

<p>We can easily convert an optimization problem to a decision problem by asking: is there a
solution that has value lower than (or higher than) a given value? </p>

<!-- ---------------------------- -->
<h3>Encodings and Concrete Problems</h3>

<p>To specify whether an abstract problem is solvable in polynomial time, we need to carefully
specify the size of the input.</p>

<p>An <b>encoding</b> of a problem maps problem instances to binary strings. We consider only
"reasonable" encodings</p>
<ul>
  <li>For example, we do not represent numbers in unary format. If we did, the input to the problem
    of enumerating all binary strings of length <i>n</i> would itself be of length
    2<sup><i>n</i></sup>, so an "O(<i>n</i>)" solution would be possible!</li> <br>
  <li>A "reasonable" encoding an integer is polynomial related to its representation, and a set of
    objects polynomially related to its encoding. Standard codings such as ASCII meet this
    requirement.</li> 
</ul> 

<p>Once problems and their solutions are encoded, we are dealing with <b>concrete problem
instances</b>. Then a problem <i>Q</i> can be thought of as a function <i>Q</i> : {0, 1}<sup>*</sup>
&rarr; {0, 1}<sup>*</sup>, or if it is a decision problem, <i>Q</i> : {0, 1}<sup>*</sup> &rarr; {0,
1}. (<i>Q</i>(<i>x</i>) = 0 for any string <i>x</i> &in; &Sigma;<sup>*</sup> that is not a legal
encoding.) </p>

<!-- ---------------------------- -->
<h3>Accepting and Deciding Formal Langauges</h3>

<p>By casting computational problems as decision problems, theorists can use concepts from formal
language theory in their proofs. We are not doing these proofs but you should be aware of the basic
concepts and distinctions:</p> 

<p>A <b>language</b> <i>L</i> over an alphabet &Sigma; is a set of strings made up of symbols from
&Sigma;. For example, if &Sigma; = {0, 1}, the set <i>L</i> = {10, 11, 101, 111, 1011, 1101, 10001,
...} is the language of binary representations of prime numbers.</p>

<p> The language that contains all strings over &Sigma; is denoted &Sigma;<sup>*</sup>. For example,
if &Sigma; = {0, 1}, then &Sigma;<sup>*</sup> = {&epsilon;, 0, 1, 00, 01, 10, 11, 000, ...}, where
&epsilon; denotes an empty string.</p> 

<p>An algorithm <i>A</i> <b> accepts</b> a string <i>x</i> &in; {0, 1}<sup>*</sup> if given <i>x</i>
the output of <i>A</i> is 1.</p>

<p>The <b>language <i>L</i> accepted by <i>A</i></b> is the set of strings <i>L</i> = {<i>x</i> &in;
{0, 1}<sup>*</sup> : <i>A</i>(<i>x</i>) = 1}.</p>

<p>But <i>A</i> need not halt on strings not in <i>L</i>. It could just never return an answer. (The
existence of problems like the Halting Problem necessitate considering this possibility.) </p>

<p>A language is <b>decided</b> by an algorithm A if it accepts precisely those strings in L
<em>and</em> rejects those not in L (i.e., <i>A</i> is guaranteed to halt with result 1 or 0). </p>

<p>A language is <b>accepted in polynomial time</b> by A if it is accepted by A in time
O(<i>n<sup>k</sup></i>) for every encoded input of length <i>n</i> and some constant
<i>k</i>. Similarly, a language is <b>decided in polynomial time</b> by A if it is decided by A in
time O(<i>n<sup>k</sup></i>).</p>

<!-- ---------------------------- -->
<h3> Polynomial Time Verification </h3>

<p>A <b>complexity class</b> is a set of languages for which membership is determined by a
complexity measure. (Presently we are interested in the running time required of any algorithm that
decides <i>L</i>, but complexity classes can also be defined by other measures, such as space
required.) For example, we can now define P more formally as:</p>

<blockquote>
<b>P</b> = {<i>L</i> &sube; {0, 1}<sup>*</sup> : &exist; algorithm <i>A</i> that decides <i>L</i> in
polynomial time}. 
</blockquote>

<p>A <b>verification algorithm <i>A</i>(<i>x</i>, <i>y</i>)</b> takes two arguments: an <b>encoding
<i>x</i></b> of a problem and a <b>certificate <i>y</i></b> for a solution. <i>A</i> returns 1 if the
solution is valid for the problem. (<i>A</i> need not solve the problem; only verify the proposed
solution.) </p>

<p>The <b>language verified</b> by a verification algorithm <i>A</i> is </p> 
<blockquote>
L = {<i>x</i> &in; {0, 1}<sup>*</sup>: &exist; <i>y</i> &in; {0, 1}<sup>*</sup> such that
<i>A</i>(<i>x</i>, <i>y</i>) = 1}. 
</blockquote>

<p>We can now define the complexity class <b>NP</b> as the class of languages that can be verified
by a polynomial time algorithm, or formally:</p>

<blockquote>
  <i>L</i> &in; NP iff &exist; polynomial time algorithm <i>A</i>(<i>x</i>, <i>y</i>) and constant
  <i>c</i> such that:
  <blockquote>
    <i>L</i> = {<i>x</i> &in; {0,1}<sup>*</sup> : &exist; certificate <i>y</i> with |<i>y</i>| =
    O(|<i>x</i>|<sup><i>c</i></sup>) such that <i>A</i>(<i>x</i>,<i>y</i>) = 1}.
  </blockquote>
</blockquote>

<img src="Topic-24/Fig-34-2-Hamilton-Examples-a.jpg" align="right" hspace="5">

<p>The constant <i>c</i> ensures that the size of the certificate <i>y</i> is polynomial in the
problem size, and also we require that <i>A</i> runs in time polynomial in its input, which
therefore must be polynomial in both |<i>x</i>| and |<i>y</i>|. </p>

<p>For example, although only exponential algorithms are known for the Hamiltonian Cycle problem, a
proposed solution can be encoded as a sequence of vertices and verified in polynomial time. </p>

<p>&nbsp;</p>

<!-- ------------------------------------------------------------ -->
<hr><h2> NP Completeness </h2>

<p>The NP-Complete problems are the "hardest" problems in NP, in that if one of them can be solved
in polynomial time then every problem in NP can be solved in polynomial time. This relies on the
concept of <i>reducibility</i>. </p>

<!-- ---------------------------- -->
<h3>Reducibility </h3>

<img src="Topic-24/Fig-34-1-reduction-algorithm.jpg">

<p>A problem <i>A</i> can be polynomially reduced to a problem <i>B</i> if there exists a
polynomial-time computable function <i>f</i> that converts an instance &alpha; of <i>A</i> into an
instance &beta; of <i>B</i>.</p>

<img src="Topic-24/Fig-34-4-Polynomial-Reduction.jpg" align="right" hspace="5">

<p>Stated in terms of formal languages, <i>L</i><sub>1</sub> is reducible to <i>L</i><sub>2</sub> if
there exists a polynomial-time computable function <i>f</i> : {0, 1}<sup>*</sup>  &rarr; {0,
1}<sup>*</sup>  such that:</p>
<blockquote>
  <i>x</i> &in; <i>L</i><sub>1</sub> iff <i>f</i>(<i>x</i>) &in; <i>L</i><sub>2</sub>, &forall;
<i>x</i> &in;{0, 1}<sup>*</sup>. 
</blockquote>

<p>As shown in the figure, exactly those instances that are in <i>L</i><sub>1</sub> are in
<i>L</i><sub>2</sub>. </p>

<!-- ---------------------------- -->
<h3>NP Completeness Defined </h3>

<p>A language <i>L</i> &sube; {0, 1}<sup>*</sup> is <b>NP-Complete (in NPC) if</b> </p>
<ol>
  <li><b><i>L</i> &in; NP</b>, and </li>
  <li><b>Every <i>L'</i> &in; NP is polynomial reducible to <i>L</i>.</b></li> 
</ol> 

<p>Languages satisfying 2 but not 1 are said to be <b>NP-Hard</b>. (This includes optimization
problems that can be converted to decision problems in NP.)</p>

<p>The major Theorem of this lecture is:</p>
<big>
<blockquote>
<b>If any NP-Complete problem is polynomial-time solvable, then P = NP. </b>
</blockquote>
<img src="Topic-24/Fig-34-6-Complexity-Class-Relations.jpg" align="right" hspace="5">
<blockquote>
Equivalently, <b>if any problem in NP is not polynomial-time solvable, then no NP-Complete problem
is  polynomial time solvable.</b>
</blockquote>
</big>

<p>The expected situation (but by no means proven) corresponds to the second statement of the
theorem, as depicted to the right.</p>

<p>&nbsp;</p>

<!-- ------------------------------------------------------------ -->
<hr><h2> Constructing NPC </h2>

<p>In order to construct the class NPC, we need to have one problem known to be in NPC. Then we can
show that other problems are in NPC by reducibility proofs (reducing the other candidates to this
known problem).</p>

<!-- ---------------------------- -->
<h3>Circuit Satisfiability: An Initial Problem</h3>

<p>In 1971, Cook defined the class NPC and proved that it is nonempty by proving that the
<b>Circuit Satisfiability <i> (CIRCUIT-SAT)</i></b> problem is NP-Complete.</p>

<img src="Topic-24/Fig-34-10-CircuitSat-FormulaSat.jpg" align="right" hspace="5">

<p>This problem asks: given an acyclic boolean combinatorial circuit composed of AND, OR and NOT
gates, does there exist an assignment of values to the input gates that produces a "1" at a
designated output wire? Such a circuit is said to be <b>satisfiable</b>.</p>

<p>The first part of the proof, that CIRCUIT-SAT is in NP, is straightforward.</p>
<ul>
  
  <li> Given as certifiate an assignment of boolean values to each of the wires in a circuit, one
       can check that the assignment meets the logic conditions of each component, which clearly can
       be done in polynomial time in the size of the description of the circuit.</li>

  <li> Alternatively, one can give as certificate only the input values, and verify by simulating
      the circuit, propagating values through the gates and to the designated output wire, in
      polynomial time.</p>
</ul>

<p>The second part of the proof, that CIRCUIT-SAT is NP-Hard, was complex. The gist was as
follows.</p>


<ul>
  
  <li> Given any language <i>L</i> corresponding to a problem in NP, there must exist an algorithm
      <i>A</i> that verifies <i>L</i> in polynomial time <i>T</i>(<i>n</i>), where <i>n</i> is the
      input size..</li><br>
      
      <img src="Topic-24/Fig-34-9-Circuit-Satisfiability-Algorithm.jpg" align="right" hspace="5">

  <li> We can represent the computation of <i>A</i> as a sequence of configurations or states of a
      machine <i>M</i> on which the algorithm runs. (A configuration represents the state of the
      computer, including program, storage and program counters.)  </li><br>

  <li> First, a boolean circuit corresponding to <i>M</i> is constructed. </li><br> 

  <li> Then the reduction makes a copy of the boolean circuit for each possible state (computational
      configuration) of <i>M</i>, feeding the output of one configuration into the input of another
      configuration in such a manner that computer memory is no longer needed: all state is encoded
      in the circuit wiring (<i>c</i><sub><i>i</i></sub> in the figure). The result is a single
      combinatorial circuit.</li><br>

  <li> Crucially, this transformation can be done in polynomial time. <i>A</i> verifies <i>L</i> in
      polynomial time, meaning that the number of state changes <i>T</i>(<i>n</i>) is bounded by a
      polynomial function of the input size <i>n</i>, so we only need a polynomial number of copies
      of <i>M</i> with input and output wires for <i>c</i><sub>0</sub>
      ... <i>c</i><sub><i>T</i>(<i>n</i>)</sub> as shown in the figure. The size of each copy is
      also polynomially related to <i>n</i>. Thus the whole construction is polynomial in
      <i>n</i>. </li><br>
      
  <li>Then an algorithm that solves CIRCUIT-SAT can be used to simulate <i>A</i>, deciding
  <i>L</i> (we read the the circuit wire corresponding to the 0/1 decision in <i>A</i>'s working
  memory).</li>  

</ul>

<!-- ---------------------------- -->
<h3>NP Completeness Proofs by Reduction</h3>

<p>Polynomial reduction is transitive:</p>

<blockquote>
   If <i>L</i> is a language such that <i>L'</i> reduces polynomially to <i>L</i> for some <i>L'</i>
  &in; NPC, then <i>L</i> is NP-Hard.
</blockquote>

<blockquote>
   Furthermore, if <i>L</i> &in; NP, then <i>L</i> &in; NPC. 
</blockquote>

<p>Transitivity follows from the definitions and that the sum of two polynomials is itself
polynomial.</p> 

<p>This means that we can prove that other problems are in NPC without having to reduce every
possible problem to them. The general procedure for proving that <i>L</i> is in NPC is:  </p>
<big>
<ol>
  <li><b>Prove <i>L</i> &in; NP</b> (show one can check solutions in polynomial time).</li>
  <li><b>Prove <i>L</i> is NP-Hard</b>:</li>
    <ol> 
      <li>Select a known language <i>L'</i> in NPC</li>
      <li>Describe an algorithm <i>A</i> that computes function <i>f</i> mapping <em>every</em>
          instance <i>x</i> &in; {0, 1}<sup>*</sup> of <i>L'</i> to <em>some appropriately
          constructed</em> instance <i>f</i>(<i>x</i>) of <i>L</i>. </li>
      <li>Prove that x &in; <i>L'</i> iff <i>f</i>(<i>x</i>) &in; <i>L</i>, &forall; <i>x</i> &in; 
          {0, 1}<sup>*</sup>. </li>
      <li>Prove that <i>A</i> runs in polynomial time.</li>
    </ol>
  </li> 
</ol> 
</big> 
<p><em>Important:</em> Why doesn't mapping <em>every</em> instance of <i>L</i> to <em>some</em>
instances of <i>L</i>' work?</p>

<p>Now we can populate the class NPC, first by reducing some problems to CIRCUIT-SAT, and then other
problems to these new problems. Literally thousands of problems have been proven to be in NPC by
this means. Let's look at a few.</p>

<!-- ------------------------------------------------------------ -->
<hr><img src="Topic-24/Fig-34-13-Structure-of-NPC-Proofs.jpg" align="right" hspace="5">
<h2> NP Complete Problems </h2>

<p>The text steps through reduction of problems as shown in the figure. We do not have time to go
through the proofs, and it is more important that you are aware of the diversity of problems in NPC
than that you are able to do NP-Completeness proofs. So we just list them briefly.</p>

<!-- ---------------------------- -->
<h3>Satisfiability (SAT)</h3>

<p>An instance is a boolean formula &phi; composed of </p>
<ul>
  <li><i>n</i> boolean variables <i>x</i><sub>1</sub> ... <i>x</i><sub><i>n</i></sub>, </li>

  <li><i>m</i> boolean connectives of two inputs and one output: &and; (logical <b>and</b>), &or;
  (logical <b>or</b>), &not; (logical <b>not</b>), &rarr; (logical <b>implication</b>), &harr;
  (logical <b>equivalence</b>), and </li> <li>parentheses.</li>
  
</ul>

<p>A <b>truth assignment</b> is a set of values for the variables of &phi; and a <b> satisfying
assignment</b> is a truth assignment that evaluates to 1 (true).</p> 

<blockquote>
  SAT = {&lang;&phi;&rang; : &phi; is a satisfiable boolean formula} 
</blockquote>

<p>There are 2<sup><i>n</i></sup> possible assignments, but a given assignment can be checked in
polynomial time.</p>

<img src="Topic-24/Fig-34-10-CircuitSat-FormulaSat.jpg" align="right" hspace="5">

<p>CIRCUIT-SAT is reduced to SAT in polynomial time through a construction that turns CIRCUIT-SAT
gates into small logical formulas for SAT:</p>

<ol>
  <li>Given any instance of CIRCUIT-SAT, define a variable <i>x<sub>i</sub></i> for each of the wires.</li>
  <li>Write a formula &phi; that is the conjunction of the variable for the output wire plus a
  logical expression for each of the logic gates.</li>
</ol>

<p>The resulting boolean formula is satisfied just when the circuit is satisfied. (You can verify
that the formula shown is equivalent to the circuit.)</p>

<blockquote>
<i>x</i><sub>10</sub>
&and; (<i>x</i><sub>4</sub> &harr; &not; <i>x</i><sub>3</sub>)
&and; (<i>x</i><sub>5</sub> &harr; (<i>x</i><sub>1</sub> &or; <i>x</i><sub>2</sub>))
&and; (<i>x</i><sub>6</sub> &harr; &not; <i>x</i><sub>4</sub>)
&and; (<i>x</i><sub>7</sub> &harr; (<i>x</i><sub>1</sub> &and; <i>x</i><sub>2</sub> &and;
<i>x</i><sub>4</sub>))
&and; (<i>x</i><sub>8</sub> &harr; (<i>x</i><sub>5</sub> &or; <i>x</i><sub>6</sub>))
&and; (<i>x</i><sub>9</sub> &harr; (<i>x</i><sub>6</sub> &or; <i>x</i><sub>7</sub>))
&and; (<i>x</i><sub>10</sub> &harr; (<i>x</i><sub>7</sub> &and; <i>x</i><sub>8</sub> &and;
<i>x</i><sub>9</sub>))
</blockquote>

<p>This shows that we can reduce an arbitrary instance of CIRCUIT-SAT to a specialized instance of
SAT in polynomial time. That means if we can solve SAT (e.g., in polynomial time) we can solve any
instance of CIRCUIT-SAT in polynomially related time, <em>and</em> since we know that CIRCUIT-SAT is
NPC, <u>transitively</u> we can use SAT to solve any instance of <em>any problem</em> in NP: <b>SAT
&larr; CIRCUIT-SAT</b> and <b>CIRCUIT-SAT &larr; Problems in NP</b> implies <b>SAT &larr; Problems
in NP</b>. Furthermore, only a polynomial cost is incurred in the translation, so the time required
to solve SAT is polynomially related to that of the problems in NP.</p>

<p>Mapping an arbitrary instance of SAT to a specialized instance of CIRCUIT-SAT would not
work. Such a reduction would go in the wrong direction to give logical transitivity: CIRCUIT-SAT
&larr; SAT and CIRCUIT-SAT &larr; Problems in NP does not let us infer SAT &larr; Problems in
NP). </p>

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<h3>3-Conjunctive Normal Form Satisfiability (3-CNF-SAT)</h3>

<p>Reduction proofs require that we handle any possible case of a known NPC problem. It would be
complicated to handle all the possible forms of SAT formulas, so it is useful to have a more
restricted logical form for the target for reduction proofs. 3-CNF serves this purpose.</p>

<p>A <b>literal</b> in a boolean formula is an occurrence of a variable or its negation.</p>

<p>A boolean formula is in <b>conjunctive normal form (CNF)</b> if it is a conjunction of
<b>clauses</b>, each of which is the disjunction of one or more literals.</p>

<p>A boolean formula is in <b>3-conjunctive normal form (3-CNF)</b> if each clause has exactly three
distinct literals. For example: </p> 
<blockquote>
  (<i>x</i><sub>1</sub>&or; &not;<i>x</i><sub>1</sub> &or; &not;<i>x</i><sub>2</sub>) &and;
  (<i>x</i><sub>3</sub> &or; <i>x</i><sub>2</sub> &or; <i>x</i><sub>4</sub>) &and;
  (&not;<i>x</i><sub>1</sub> &or; &not;<i>x</i><sub>3</sub> &or; &not;<i>x</i><sub>4</sub>) 
</blockquote>

<p>3-CNF-SAT asks whether a boolean formula is satisfiable by an assignment of truth values to the
variables.</p>

<p>There are an exponential possible number of variable assignments, but a given one can be
checked in polynomial time merely by substituting and evaluating the expression.</p> 

<p>SAT can be reduced to 3-CNF-SAT through a polynomial-time process of:</p>
<ol>
  <li> parsing the SAT expression into a binary tree with literals as leaves and connectives as
       internal nodes; </li>
  <li> introducing a variable <i>y<sub>i</sub></i> for the output of each internal node; </li>
  <li> rewriting as the conjunction of the root variable and a clause for each node of the binary 
       tree (<i>y<sub>i</sub></i> &harr; the literal for its child nodes); </li> 
  <li> converting each clause to conjunctive normal form (see text), first by converting to
       disjunctive normal
       form and then applying DeMorgan's laws to convert to CNF; and then </li>
  <li> supplying dummy variables as needed to convert clauses of 1 or 2 variables into 3-CNF.</li> 
</ol>

<img src="Topic-24/Fig-34-11-Phi-Tree.jpg" align="right" hspace="5">

<p> For ((<i>x</i><sub>1</sub> &rarr; <i>x</i><sub>2</sub>) &or; &not;((&not;<i>x</i><sub>1</sub>
&harr; <i>x</i><sub>3</sub>) &or; <i>x</i><sub>4</sub>)) &and; &not;<i>x</i><sub>2</sub>, the tree
is shown to the right and the expression resulting from the tree is shown below. </p>

<blockquote>
  <i>y</i><sub>1</sub>
  &and; (<i>y</i><sub>1</sub> &harr; (<i>y</i><sub>2</sub> &and; &not;<i>x</i><sub>2</sub>))
  &and; (<i>y</i><sub>2</sub> &harr; (<i>y</i><sub>3</sub> &or; <i>x</i><sub>4</sub>))
  <br> &nbsp; &nbsp;
  &and; (<i>y</i><sub>3</sub> &harr; (<i>x</i><sub>1</sub> &rarr; <i>x</i><sub>2</sub>))
  &and; (<i>y</i><sub>4</sub> &harr; &not;<i>y</i><sub>5</sub>)
  <br> &nbsp; &nbsp;
  &and; (<i>y</i><sub>5</sub> &harr; (<i>y</i><sub>6</sub> &or; <i>x</i><sub>4</sub>))
  &and; (<i>y</i><sub>6</sub> &harr; (&not;<i>x</i><sub>1</sub> &harr; <i>x</i><sub>3</sub>))
</blockquote>

<p>The remainder of the conversion uses DeMorgan's laws (see the text for the step by step description):</p>

<blockquote>
&not;(<i>a</i> &and; <i>b</i>) &equiv; &not;<i>a</i> &or; &not;<i>b</i><br>
&not;(<i>a</i> &or; <i>b</i>) &equiv; &not;<i>a</i> &and; &not;<i>b</i>
</blockquote>

<p>resulting in: </p>

<blockquote>
(&not;<i>y</i><sub>1</sub> &or; &not;<i>y</i><sub>2</sub> &or; &not;<i>x</i><sub>2</sub>)
&and; (&not;<i>y</i><sub>1</sub> &or; <i>y</i><sub>2</sub> &or; &not;<i>x</i><sub>2</sub>)
&and; (&not;<i>y</i><sub>1</sub> &or; <i>y</i><sub>2</sub> &or; <i>x</i><sub>2</sub>)
&and; (<i>y</i><sub>1</sub> &or; &not;<i>y</i><sub>2</sub> &or; <i>x</i><sub>2</sub>).
</blockquote> 

<img src="Topic-24/cliques.jpg" align="right" hspace="5"> 

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<h3>CLIQUE</h3>

<p>A <b>clique</b> in an undirected graph <i>G</i> = (<i>V</i>, <i>E</i>) is a subset <i>V'</i>
&sube; <i>V</i>, each pair of which is connected by an edge in <i>E</i> (a complete subgraph of
<i>G</i>). (Examples of cliques of sizes between 2 and 7 are shown on the right.)</p>

<p>The <b>clique problem</b> is the problem of finding a clique of maximum size in <i>G</i>. This can
be converted to a decision problem by asking whether a clique of a given size <i>k</i> exists in the
graph:</p>
<blockquote>
  CLIQUE = {&lang;<i>G</i>, <i>k</i>&rang; : <i>G</i> is a graph containing a clique of size <i>k</i>}
</blockquote>

<p>One can check a solution in polynomial time. <i>(How?)</i></p>
<br>
<img src="Topic-24/Fig-34-14-3-CNF-to-Clique.jpg" align="right" hspace="5">

<p>3-CNF-SAT is reduced to CLIQUE by a clever reduction illustrated in the figure. Given an
arbitrary formula &phi; in 3-conjunctive normal form with <i>k</i> clauses, we construct a graph
<i>G</i> and ask if it has a clique of size <i>k</i> as follows: </p>

<ul>
  <li>We create a vertex for every literal in &phi;</li>

  <li>For every pair of vertices, we create an edge between them if the corresponding literals are
  in different triples <em>and</em> the literals are consistent (i.e., one is not the negation of
  the other).</li>
  
</ul>

<p>If there are <i>k</i> clauses in &phi;, we ask whether the graph has a <i>k</i>-clique. The claim
is that such a clique exists in <i>G</i> if and only if there is a satisfying assignment for
&phi;:</p>

<ul>
  <li> <b> If </b> direction <i>(If clique exists in <i>G</i>, then there is a satisfying assignment
       in &phi;)</i>:</li> 
  <ul>
    
    <li> By definition of <i>k</i>-clique, existence of a <i>k</i>-clique implies there are <i>k</i>
	 vertices in <i>G</i> that are all connected to each other. </li>
         
    <li> By our construction, the fact that two vertices are connected to each other means that they
	 can receive a consistent boolean assignment (we can assign 1 to all of them), <em>and</em>
	 that they are in different clauses.</li>
         
    <li> Since there are <i>k</i> vertices in the clique, then at least one literal in each of the
	 <i>k</i> clauses can be assigned a 1, i.e., the formula &phi; can be satisfied. </li>
         
  </ul>
  
  <li> <b> Only if </b> direction <i>(If &phi; can be satisfied, then there is a clique in
       <i>G</i>)</i>: 
  <ul>
    
    <li> If &phi; can be satisfied, then we can assign values to the literals, such that at least
	 one literal in each clause is assigned value 1. I.e. they are consistent.
    
    <li> Consider the vertices corresponding to those literals. Since the literals are consistent
	 and they are in different clauses, there is an edge between every pair of them.
    
    <li> Since there are <i>k</i> clauses in &phi; we have a subset of at least <i>k</i> vertices in
	 the graph with edges between every pair of vertices, i.e., we have a <i>k</i>-clique in
	 <i>G</i>.</li>
    
  </ul>
</ul>

<p>Any arbitrary instance of 3-CNF-SAT can be converted to an instance of CLIQUE in polynomial time
with this particular structure. That means if we can solve CLIQUE we can solve any instance of
3-CNF-SAT, and since we know that 3-CNF-SAT is NPC, transitively we can solve any instance in NP in
polynomially related time. Be sure you understand why mapping an arbitrary instance of CLIQUE to a
specialized instance of 3-CNF-SAT would not work.</p>

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<h3>Vertex Cover</h3>

<img src="Topic-24/vertex-cover-example.jpg" align="right" hspace="5">

<p>A vertex cover of an undirected graph <i>G</i> = (<i>V</i>, <i>E</i>) is a subset <i>V'</i>
&sube; <i>V</i> such that if (<i>u</i>, <i>v</i>) &in; <i>E</i> then <i>u</i> &in; <i>V'</i> or
<i>v</i> &in; <i>V'</i> or both.</p>

<p>Each vertex "covers" its incident edges, and a vertex cover for <i>G</i> is a set of vertices
that covers all the edges in <i>E</i>. For example, in the graph on the right, <i>V' = {v, z}</i> or
<i>V' = {v, w, y}</i> are vertex covers. Note <i>V' = V = {u, v, w, x, y, z}</i> is also a vertex
cover. </p>

<p>The <b>Vertex Cover Problem</b> is to find a vertex cover of minimum size in <i>G</i>. Phrased
as a decision problem, </p>
<blockquote>
  VERTEX-COVER = {&lang;<i>G</i>, <i>k</i>&rang; : graph <i>G</i> has a vertex cover of size <i>k</i>}
</blockquote>

<img src="Topic-24/Fig-34-15-Clique-to-Vertex-Cover.jpg" align = "right">

<p>There is a straightforward reduction of CLIQUE to VERTEX-COVER, illustrated in the figure. Given
an instance <i>G</i>=(<i>V</i>,<i>E</i>) of CLIQUE, one computes the complement of <i>G</i>, which
we will call <i>G<sub>c</sub></i> = (<i>V</i>,<i>&Emacr;</i>), where (<i>u</i>,<i>v</i>) &in;
<i>&Emacr;</i> iff (<i>u</i>,<i>v</i>) &notin; <i>E</i>.</p>

<p>The graph <i>G</i> has a clique of size <i>k</i> iff the complement graph has a vertex cover of
size |<i>V</i>| &minus; <i>k</i>. (<em>Note</em> that this is an existence claim, not a minimization
claim: a smaller cover may be possible.)  </p>

<ul>
  
<li> <b>If</b> direction <i>(If G has a k-clique, then G<sub>c</sub> has a vertex cover of size |V|
     &minus; k)</i>:<br>

    We show that none of the <i>k</i> vertices in the clique need to be in the cover.
  
  <ul>

    <li> They are all connected to each other in <i>G</i>, so none of them will be connected to each
	 other in <i>G<sub>c</sub></i>.</li>

    <li> Thus, every edge in <i>G<sub>c</sub></i> must involve at least one vertex not in the
	 clique, so the clique vertices can be excluded from the cover: we can use vertices from the
	 remaining |<i>V</i>| &minus; <i>k</i> vertices to cover all the edges in
	 <i>G<sub>c</sub></i>.</li>

    <li>The minimum vertex cover may be smaller than |<i>V</i>| &minus; <i>k</i>, but we know that
        |<i>V</i>| &minus; <i>k</i> will work.</li>
	 
  </ul><br></li> 

<li><b> Only if </b> direction <i>(If G<sub>c</sub> has a vertex cover of size |V| &minus; k, then G
    has a k-clique)</i>:

    <br> We will use proof by contrapositive to show that there is no clique of size <i>k</i> in
    <i>G</i>, then there is no vertex cover of size <i>|V| &minus; k</i> in <i>G<sub>c</sub></i>.

  <ul>
  
    <li> Assume for the sake of contradiction that there is no <i>k</i>-clique in <i>G</i>, but
         there is a vertex cover <i>V'</i>  in <i>G<sub>c</sub></i> of size <i>|V'| = |V| &minus;
         k</i>. 
    
    <li> The non-existence of a <i>k</i>-clique in <i>G</i> means that at least two vertices in
         <u>every</u> subset of <i>k</i> vertices are not connected in <i>G</i>.
    
    <li> Consider the subset <i>V</i> \ <i>V'</i>, i.e. a subset of <i>k</i> vertices that are not
         part of the presumed (<i>|V| &minus; k</i>)-sized vertex cover of <i>G<sub>c</sub></i>. By
         the above, there exist at least two vertices in this subset (let's call them <i>u</i> and
         <i>v</i>), such that there is no edge (<i>u,v</i>) in <i>G</i>. </li>

    <li> But if edge (<i>u,v</i>) is not in <i>G</i>, it must exist in <i>G<sub>c</sub></i> (the
         complement of <i>G</i>). </li>

    <li> But if there is an edge (<i>u,v</i>) in <i>G<sub>c</sub></i>, and neither <i>u</i> nor
         <i>v</i> are in the vertex cover, then edge (<i>u,v</i>) is uncovered and <i>V'</i> is not
         a valid vertex cover.</li>
       
  </ul>

  We reached a contradiction, therefore, if <i>G</i> does not contain a <i>k</i>-clique,
  <i>G<sub>c</sub></i> cannot contain a vertex cover of size <i>|V| &minus; k</i></li>

</ul> 

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<h3> Hamiltonian Cycle (HAM-CYCLE)</h3>

<p>A graph <i> G = (V,E)</i> contains a <i><b>Hamiltonian cycle</b></i> if it contains a simple cycle
<i>C</i> of size <i>|V|</i>. That is, <i>G</i> contains a cycle that visits every vertex exactly
once.</p>

<blockquote>
  HAM-CYCLE = {&lang;<i>G</i>&rang; : <i>G</i> contains a Hamiltonian cycle}
</blockquote>

<p>The Hamiltonian Cycle problem is shown to be in NPC by reduction of VERTEX-COVER to HAM-CYCLE.</p>

<p>Given graph <i>G</i> &mdash; an instance of VERTEX-COVER &mdash; the construction converts edges
of <i>G</i> into subgraph "widgets" shown in the figure (a) below. The Hamiltonian Cycle will go
through every vertex of the widget associated with edge each (<i>u,v</i>) if and only if one or both
of the vertices of the edge (<i>u,v</i>) are in the covering set. There is one such widget for every
edge (<i>u,v</i>) in <i>G</i>.</p>

<img src="Topic-24/Fig-34-16-Vertex-Cover-Ham-Cycle.jpg" hspace="5">

<p>Any Hamiltonian cycle must include all the vertices in the widget (a), but there are only three ways
to pass through each widget (b, c, and d in the figure). If only vertex <i>u</i> is included in the
cover, we will use path (b); if only vertex <i>v</i> then path (d); otherwise path (c) to include
both. (Not traversing the widget is not an option because at least one of the two vertices must be
chosen to cover the edge.)  </p> 

<p>The widgets are then wired together in sequences that chain all the widgets that involve a given
vertex, so if the vertex is selected all of the widgets corresponding to its edges will be
reached. </p>

<img src="Topic-24/Fig-34-17-Vertex-Cover-Ham-Cycle.jpg" hspace="5">

<p>Finally, <i>k</i> selector vertices are added, and wired such that each will select the
<i>k</i>th vertex in the cover of size <i>k</i>. I leave it to you to examine the discussion in the text, to see how clever these reductions can be!</p>

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<h3>Traveling Salesperson Problem (TSP)</h3>

<p>One of the more famous NPC problems is TSP: Suppose you are a traveling salesperson, and you want
to visit <i>n</i> cities exactly once in a Hamiltonian cycle, but choosing a <b>tour</b> with
minimum cost. </p>

<!-- img src="Topic-24/travelling_salesman_problem.jpg" align="right" -->
<img src="http://imgs.xkcd.com/comics/travelling_salesman_problem.png" width="320" height="142" align="right" hspace="5">

<blockquote>
 TSP = {&lang;<i>G</i>, <i>c</i>, <i>k</i>&rang; : <i>G</i> = (<i>V</i>, <i>E</i>) is a complete
 graph, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <i>c</i> : <i>V</i> x <i>V</i> &rarr;
 <big>&naturals;</big>, <br> 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <i>k</i> &in; <big>&naturals;</big>, and <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <i>G</i> has a traveling-salesperson tour with cost at most <i>k</i>} 
</blockquote>

<p>Only exponential solutions have been found to date, although it is easy to check a solution in
polynomial time.</p>

<p>The reduction represents a HAM-CYCLE problem as a TSP problem on a complete graph, but with the
cost of the edges in TSP being 0 if the edge is in the HAM-CYCLE problem, or 1 if not. </p>

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<!-- img src="Topic-24/np_complete.jpg" align="right" hspace="5" -->
<img src="http://imgs.xkcd.com/comics/np_complete.png " width="320" height="207" align="right" hspace="5">

<h3>Subset-Sum Problem (SUBSET-SUM)</h3>

<p>Many NP-Complete problems are of a numerical nature. We already mentioned integer linear
programming. Another example is the subset-sum problem: given a finite set <i>S</i> of positive
integers and an integer target <i>t</i> > 0, does there exist a subset of <i>S</i> that sums to
<i>t</i>?</p> 
<blockquote>
SUBSET-SUM = {&lang;<i>S</i>, <i>t</i> : &exist; subset <i>S'</i> &sube; <i>S</i> such that <i>t</i>
            = &Sigma;<sub><i>s</i>&in;<i>S'</i></sub> <i>s</i>} 
</blockquote>

<p>The proof reduces 3-CNF-SAT to SUBSET-SUM. Please see the text for the details
of yet another clever reduction!</p>

<p>Briefly: </p>


<img src="Topic-24/Fig-34-19-3-CNF-Sat-to-Subset-Sum.jpg" align="right" hspace="5">

<ul>

  <li> It involves constructing two numbers for each variable <i>x<sub>i</sub></i> (one for the
varaible and one for its negation), and two numbers for each clause <i>C<sub>j</sub></i> (these will
hold "slack variables" needed to meet the target sum). </li>

  <li> The digits of the numbers are arranged in
columns. </li>

  <li> The numbers for literals (variables and their negations) have a "1" in the column that
indicates which variable it corresponds to, and also a "1" in the columns for the clauses in which
that literal occurs.</li> 

  <li> The numbers for clauses have either a 1 or a 2 in the column corresponding to that
  clause.</li>

  
  <li> The target value <i>t</i> has a 1 in each digit labeled by a variable and a 4 in each digit
  labeled by a clause. </li> 

  <li> The only way one can achieve this target sum is to select those numbers corresponding to the
  literals that are satisfied in each clause, plus the required slack variables to reach 4. </li>
  
</ul>

<p>For example, see how this clause maps to the table shown:</p>

<blockquote>
           (<i>x</i><sub>1</sub> &or; &not;<i>x</i><sub>2</sub> &or; &not;<i>x</i><sub>3</sub>)
&and; (&not;<i>x</i><sub>1</sub> &or; &not;<i>x</i><sub>2</sub> &or; &not;<i>x</i><sub>3</sub>)
&and; (&not;<i>x</i><sub>1</sub> &or; &not;<i>x</i><sub>2</sub> &or; <i>x</i><sub>3</sub>)
&and;      (<i>x</i><sub>1</sub> &or;      <i>x</i><sub>2</sub> &or; <i>x</i><sub>3</sub>).
</blockquote> 

<p>&nbsp;</p> 
<!-- ---------------------------- -->
<h3> Other Problems </h3>

<p>One can find large catalogs of other problems online, starting with those identified in the book
Garey & Johnson (1979), Computers and Intractability. See for example <a
href="http://en.wikipedia.org/wiki/List_of_NP-complete_problems">Wikipedia</a>. Following Garey &
Johnson's outline they list problems in:</p>

<ol> 
  <li> Graph theory
  <ol> 
    <li> Covering and partitioning</li>
    <li> Subgraphs and supergraphs</li>
    <li> Vertex ordering</li>
    <li> Iso- and other morphisms</li>
    <li> Miscellaneous</li>
  </ol>
  </li> 
  
 <li> Network design
  <ol> 
    <li> Spanning trees</li>
    <li> Cuts and connectivity</li>
    <li> Routing problems</li>
    <li> Flow problems</li>
    <li> Miscellaneous</li>
    <li> Graph Drawing</li>
  </ol>
  </li>
  
  <li> Sets and partitions
   <ol> 
    <li> Covering, hitting, and splitting</li>
    <li> Weighted set problems</li>
    <li> Set partitions</li>
   </ol>
  </li>
  
  <li> Storage and retrieval
   <ol> 
    <li> Data storage</li>
    <li> Compression and representation</li>
    <li> Database problems</li>
  </ol>
  </li>  

 <li> Sequencing and scheduling
    <ol> 
    <li> Sequencing on one processor</li>
    <li> Multiprocessor scheduling</li>
    <li> Shop scheduling</li>
    <li> Miscellaneous</li>
  </ol>
  </li> 

  <li> Mathematical programming</li>
  
  <li> Algebra and number theory</li> 
   <ol> 
    <li> Divisibility problems</li>
    <li> Solvability of equations</li>
    <li> Miscellaneous</li>
  </ol>
  </li>
  
 <li> Games and puzzles</li> 

 <li> Logic
   <ol> 
    <li> Propositional logic</li>
    <li> Miscellaneous</li>
   </ol>
   </li>
   
  <li> Automata and language theory
  <ol> 
    <li>1 Automata theory</li>
    <li>2 Formal languages</li>
  </ol>
  </li>
  
  <li> Computational geometry</li> 

  <li>Program optimization</li> 
  <ol> 
    <li>1 Code generation</li>
    <li>2 Programs and schemes</li>
  </ol> 

  <li> Miscellaneous</li>
</ol>

<p>There are also  problems for which their status is as of yet unknown. Much work to do!</p>

<p>If you want to learn more about NP-completeness and how to come up with NP-completeness proofs
yourself, various complexity classes, and the limits of what computers are able to compute, you
should take ICS 441.</p> 

<!-- ------------------------------------------------------------ -->
<hr>
<address>Dan Suthers</address>
<!-- hhmts start -->Last modified: Sun Apr 26 10:50:59 EDT 2015 <!-- hhmts end -->
<br>Images are from the instructor's material for Cormen et al. Introduction to Algorithms, Third
Edition; Garey & Johnson (1979), Computers and Intractability; and  Weisstein, Eric W. "Complete
Graph." From MathWorld--A Wolfram Web Resource. http://mathworld.wolfram.com/CompleteGraph.html,
xkcd.com, and possibly other sites whom I thank for not suing me.</br> 
</body>
</html>
